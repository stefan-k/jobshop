\section{evolib}\label{evolib}

Die \textit{evolib} Bibliothek wurde so ausgelegt, dass wann immer möglich und sinnvoll, die multiple dispatch Funktionalität von Julia genutzt wurde.

Als Grundstruktur werden sogenannte Types (vergleichbar mit C \texttt{struct}s) definiert, und zwar für \texttt{Gene}, \texttt{Chromosome}, \texttt{Population} und \texttt{Generation}. 
Diese Types bauen aufeinander auf, beispielsweise besteht ein \texttt{Chromosome} aus mehreren \texttt{Gene}s. 
Zusätzlich enthalten die jeweiligen Types aber auch weitere Metainformationen, wie zum Beispiel die \texttt{fitness} bei einem \texttt{Chromosome}.

Auf Basis dieser Types wird multiple dispatch durchgeführt.

\subsection{\texttt{Gene} Datentyp}

Ein \texttt{Gene} wird mit dem folgenden Datentyp repräsentiert. 
Das \texttt{gene} Feld ist vom Typ \texttt{Number}, also ein abstrakter Übertyp über alle Typen die Zahlen repräsentieren. 
Mit \texttt{std} wird die Standardabweichung definiert, welche für die Mutation eines Gens herangezogen wird.
Sollte eine Beschränkung des \texttt{gene} Feldes gewünscht sein, können \texttt{upper\_limit} und \texttt{lower\_limit} definiert werden. 
Diese Grenzen werden bei der Mutation eines Genes berücksichtigt. Werden diese auf \texttt{NaN} gesetzt, so wird \texttt{gene} nicht limitiert.
\begin{Verbatim}
type Gene <: AbstractGene
    gene::Number
    std::Float64
    upper_limit::Float64
    lower_limit::Float64

    # Constructors
    function Gene(gene::Number) 
        new(gene, 0.5, NaN, NaN) # ignore limits
    end
                                            
    function Gene(gene::Number, std::Float64) 
        new(gene, std, NaN, NaN) # ignore limits
    end
                                                            
    function Gene(gene::Number, std::Float64, upper_limit::Float64, 
                  lower_limit::Float64)
        if lower_limit >= upper_limit
            error("lower_limit must be less than upper_limit")
        end
        new(gene, std, upper_limit, lower_limit)
    end
end
\end{Verbatim}

Die Konstruktoren ermöglichen das Generieren einer Instanz des \texttt{Gene} Typs, wobei sinnvolle Defaultwerte gewählt werden wenn Parameter nicht angegeben werden.

\subsection{\texttt{Chromosome} Datentyp}

Eine Instanz des \texttt{Chromosome} Datentyps enthält einen Vektor mit \texttt{Gene}s, sowie die Länge des Vektors und die Fitness des \texttt{Chromosome}s. 
Wieder ist dank multiple dispatch möglich mehrere Konstruktoren für den Datentyp zu definieren.  
Wird keine Fitness beim Erstellen einer Instanz angegeben, so wird diese auf \texttt{Inf} gesetzt.

\begin{Verbatim}
type Chromosome <: AbstractChromosome
    genes::Vector
    length::Int64
    fitness::Float64

    # Constructors
    function Chromosome(genes::Vector) 
        new(map(copy, genes), length(genes), Inf)
    end

    function Chromosome(genes::Vector, fitness::Float64)
        new(copy(genes), length(genes), copy(fitness))
    end

    function Chromosome()
        new(Gene[], 0, Inf)
    end
end
\end{Verbatim}

\subsection{\texttt{Population} Datentyp}
Der \texttt{Population} Datentyp hält einen Vektor von \texttt{Chromosome}s und die Länge dieses Vektors in \texttt{pop\_size}.
\begin{Verbatim}
type Population <: AbstractPopulation
    chromosomes::Vector
    pop_size::Int64

    # Constructors
    # several chromosomes passed
    function Population(chromosomes::Vector) 
        new(chromosomes, length(chromosomes))
    end

    # one chromosome passed
    function Population(chromosome::Chromosome) 
        new([chromosome], 1)
    end

    # empty Population
    function Population()
        new(Chromosome[], 0)
    end
                                                                          
    function Population(size::Int)
        new(Array(Chromosome, size), size)
    end
end
\end{Verbatim}

\subsection{\texttt{Generations} Datentyp}
Mit \texttt{Generations} ist es möglich mehrere Generationen in einer Datenstruktur zu repräsentieren. 
\begin{Verbatim}
type Generations <: AbstractGenerations
    populations::Array
    generations::Int64

    # Constructors
    function Generations(population::Population)
        new([copy(population)], 1)
    end

    function Generations()
        new(Population[], 0)
    end
end
\end{Verbatim}

\subsection{\texttt{GeneticProbabilities} Datentyp}
Dieser Datentyp erleichtert das Definieren der Wahrscheinlichkeiten für die Operationen \textit{Mutation}, \textit{Recombination}, \textit{Reproduction} und \textit{Immigration} für den genetischen Algorithmus.

\begin{Verbatim}
type GeneticProbabilities <: AbstractGeneticProbabilities
    mutation::Float64
    recombination::Float64
    reproduction::Float64
    immigration::Float64

    function GeneticProbabilities(mutation::Float64, 
                                  recombination::Float64,
                                  reproduction::Float64,
                                  immigration::Float64)
        sum = mutation + recombination + reproduction + immigration
        new(mutation/sum, recombination/sum, reproduction/sum, immigration/sum)
    end
end
\end{Verbatim}

\subsection{Funktionalität}

\textit{evolib} bietet viele Funktionen die dafür sorgen, dass die Verwendung der Datentypen einfach und ``natürlich'' möglich ist. 
Beispielsweise ist es möglich über Array-Indexing mit $\left[\mathrm{i}\right]$ das $i$te Gen eines Chromosoms anzusprechen und zu modifizieren.
Mit \texttt{rand(::Type\{T\}, x\ldots)} ist es möglich einen Datentyp \texttt{T} zufällig zu initialisieren, wobei \texttt{T} für \texttt{Population}, \texttt{Chromosome} oder \texttt{Gene} stehen kann.

Weiters kann mit \texttt{sort()} und \texttt{sort!()} (in-place) eine Population anhand der Fitness der Chromosomen sortiert werden.

Algorithmen wie \texttt{roulette()}, \texttt{mutate()} und \texttt{crossover()} sind ebenfalls implementiert. 
Bei den letzten beiden gibt es die Varianten \texttt{mutate!()} und \texttt{crossover!()} die die Operationen in-place vornehmen um die Operationen im Speicher zu minimieren. 
\texttt{crossover()} bietet auch die Möglichkeit die Anzahl der Schnitte vorzugeben.

\subsection{Definieren einer Qualitätsfunktion}
Die evolutionären Algorithmen erfordern eine Qualitätsfunktion die vom Benutzer der Bibliothek definiert werden muss. 
Es ist dabei wichtig dass diese Funktion nur einen Parameter hat, da diese Funktion intern mit einem Parameter aufgerufen wird.
Dabei bietet es sich an die Qualitätsfunktion zwei mal zu definieren, einmal für den Fall dass eine \texttt{Population} übergeben wird, und einmal für \texttt{Chromosome}. 

Sollte es nötig sein der Qualitätsfunktion weitere Parameter zu übergeben, so können \texttt{lambdas} genützt werden um eine anonyme Funktion zu erzeugen die diese Eigenschaft erfüllt:

\begin{Verbatim}
objective_function = 
    (x::Union(Population, Chromosome))->real_objective_function(x, another_parameter)
\end{Verbatim}

Hierbei ist zu beachten, dass \texttt{another\_parameter} aus dem Scope kommt, in dem das \texttt{lambda} definiert wurde.

\subsection{Evolutionäre Algorithmen}
\textit{evolib} enthält den genetischen Algorithmus und die evolutionären Algorithmen vom Typ (1+1) und $(\mu/\rho, \lambda)$.
Auf eine genaue Ausführung der implementierten evolutionären Algorithmen wird hier verzichtet, da diese anhand den Blockdiagrammen im Skriptum der Lehrveranstaltung implementiert wurden. 
